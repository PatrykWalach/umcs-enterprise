"""
Connection
"""
directive @connection on OBJECT

directive @extends on INTERFACE | OBJECT

directive @external on FIELD_DEFINITION

directive @key(fields: _FieldSet!) on INTERFACE | OBJECT

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

type Admin implements Node & Viewer {
	id: ID!
}

type Basket {
	books(after: String, before: String, first: Int, last: Int): BasketBooksConnection
	id: ID!
	price: Price
	quantity: Int
}

input BasketBookInput {
	basket: WhereUniqueBasketInput
	book: WhereUniqueBookInput!
}

type BasketBookResult {
	basket: Basket
}

type BasketBooksConnection {
	edges: [BasketBooksEdge]
	pageInfo: PageInfo!
}

type BasketBooksEdge {
	cursor: String
	node: Book
	price: Price
	quantity: Int
}

type Book implements Node {
	author: String

	"""
	eslint-disable-next-line @graphql-eslint/relay-edge-types
	"""
	covers(transformations: [Transformation]): [Cover]
	id: ID!
	popularity: Int
	price: Price
	recommended(after: String, before: String, first: Int, last: Int): BookConnection
	releasedAt: DateTime
	synopsis: String
	title: String
}

type BookConnection {
	edges: [BookEdge]
	pageInfo: PageInfo!
}

type BookEdge {
	cursor: String
	node: Book
}

input BookOrderBy {
	popularity: Order
	price: PriceOrderBy
	releasedAt: Order
}

type Cover {
	crop: Crop
	height: Int
	url: String
	width: Int
}

input CreateBookInput {
	author: String!
	cover: CreateCoverInput!
	price: CreatePriceInput!
	releasedAt: DateTime!
	title: String!
}

type CreateBookResult {
	book: Book
}

input CreateCoverInput {
	file: Upload
	url: String
}

input CreatePriceInput {
	raw: Float!
}

"""
https://cloudinary.com/documentation/resizing_and_cropping#resize_and_crop_modes
"""
enum Crop {
	"""
	Extracts a region of the specified dimensions from the original image without first resizing it.
	"""
	CROP

	"""
	Resizes the image to fill the specified dimensions without distortion. The image may be cropped as a result.
	"""
	FILL

	"""
	Same as fill, but avoids excessive cropping by adding padding when needed. Supported only with automatic cropping.
	"""
	FILL_PAD

	"""
	Resizes the image to fit inside the bounding box specified by the dimensions, maintaining the aspect ratio.
	"""
	FIT

	"""
	Performs smart cropping, using the Imagga Crop and Scale add-on.
	"""
	IMAGGA_CROP

	"""
	Performs smart scaling, using the Imagga Crop and Scale add-on.
	"""
	IMAGGA_SCALE

	"""
	Same as fill, but only scales down the image.
	"""
	LFILL

	"""
	Same as fit, but only scales down the image.
	"""
	LIMIT

	"""
	Same as pad, but only scales down the image.
	"""
	LPAD

	"""
	Same as fit, but only scales up the image.
	"""
	MFIT

	"""
	Same as pad, but only scales up the image.
	"""
	MPAD

	"""
	Resizes the image to fit inside the bounding box specified by the dimensions, maintaining the aspect ratio, and applies padding if the resized image does not fill the whole area.
	"""
	PAD

	"""
	Resizes the image to the specified dimensions without necessarily retaining the original aspect ratio.
	"""
	SCALE

	"""
	Creates a thumbnail of the image with the specified dimensions, based on a specified gravity. Scaling may occur.
	"""
	THUMB
}

"""
An RFC-3339 compliant DateTime Scalar
"""
scalar DateTime

input DeleteInput {
	id: ID!
}

type DeleteResult {
	node: Node
}

enum ErrorDetail {
	"""
	The deadline expired before the operation could complete.

	For operations that change the state of the system, this error
	may be returned even if the operation has completed successfully.
	For example, a successful response from a server could have been
	delayed long enough for the deadline to expire.

	HTTP Mapping: 504 Gateway Timeout
	Error Type: UNAVAILABLE
	"""
	DEADLINE_EXCEEDED

	"""
	The server detected that the client is exhibiting a behavior that
	might be generating excessive load.

	HTTP Mapping: 429 Too Many Requests or 420 Enhance Your Calm
	Error Type: UNAVAILABLE
	"""
	ENHANCE_YOUR_CALM

	"""
	The requested field is not found in the schema.

	This differs from `NOT_FOUND` in that `NOT_FOUND` should be used when a
	query is valid, but is unable to return a result (if, for example, a
	specific video id doesn't exist). `FIELD_NOT_FOUND` is intended to be
	returned by the server to signify that the requested field is not known to exist.
	This may be returned in lieu of failing the entire query.
	See also `PERMISSION_DENIED` for cases where the
	requested field is invalid only for the given user or class of users.

	HTTP Mapping: 404 Not Found
	Error Type: BAD_REQUEST
	"""
	FIELD_NOT_FOUND

	"""
	The client specified an invalid argument.

	Note that this differs from `FAILED_PRECONDITION`.
	`INVALID_ARGUMENT` indicates arguments that are problematic
	regardless of the state of the system (e.g., a malformed file name).

	HTTP Mapping: 400 Bad Request
	Error Type: BAD_REQUEST
	"""
	INVALID_ARGUMENT

	"""
	The provided cursor is not valid.

	The most common usage for this error is when a client is paginating
	through a list that uses stateful cursors. In that case, the provided
	cursor may be expired.

	HTTP Mapping: 404 Not Found
	Error Type: NOT_FOUND
	"""
	INVALID_CURSOR

	"""
	Unable to perform operation because a required resource is missing.

	Example: Client is attempting to refresh a list, but the specified
	list is expired. This requires an action by the client to get a new list.

	If the user is simply trying GET a resource that is not found,
	use the NOT_FOUND error type. FAILED_PRECONDITION.MISSING_RESOURCE
	is to be used particularly when the user is performing an operation
	that requires a particular resource to exist.

	HTTP Mapping: 400 Bad Request or 500 Internal Server Error
	Error Type: FAILED_PRECONDITION
	"""
	MISSING_RESOURCE

	"""
	Service Error.

	There is a problem with an upstream service.

	This may be returned if a gateway receives an unknown error from a service
	or if a service is unreachable.
	If a request times out which waiting on a response from a service,
	`DEADLINE_EXCEEDED` may be returned instead.
	If a service returns a more specific error Type, the specific error Type may
	be returned instead.

	HTTP Mapping: 502 Bad Gateway
	Error Type: UNAVAILABLE
	"""
	SERVICE_ERROR

	"""
	Request failed due to network errors.

	HTTP Mapping: 503 Unavailable
	Error Type: UNAVAILABLE
	"""
	TCP_FAILURE

	"""
	Request throttled based on server concurrency limits.

	HTTP Mapping: 503 Unavailable
	Error Type: UNAVAILABLE
	"""
	THROTTLED_CONCURRENCY

	"""
	Request throttled based on server CPU limits

	HTTP Mapping: 503 Unavailable.
	Error Type: UNAVAILABLE
	"""
	THROTTLED_CPU

	"""
	The operation is not implemented or is not currently supported/enabled.

	HTTP Mapping: 501 Not Implemented
	Error Type: BAD_REQUEST
	"""
	UNIMPLEMENTED

	"""
	Unknown error.

	This error should only be returned when no other error detail applies.
	If a client sees an unknown errorDetail, it will be interpreted as UNKNOWN.

	HTTP Mapping: 500 Internal Server Error
	"""
	UNKNOWN
}

enum ErrorType {
	"""
	Bad Request.

	There is a problem with the request.
	Retrying the same request is not likely to succeed.
	An example would be a query or argument that cannot be deserialized.

	HTTP Mapping: 400 Bad Request
	"""
	BAD_REQUEST

	"""
	The operation was rejected because the system is not in a state
	required for the operation's execution.  For example, the directory
	to be deleted is non-empty, an rmdir operation is applied to
	a non-directory, etc.

	Service implementers can use the following guidelines to decide
	between `FAILED_PRECONDITION` and `UNAVAILABLE`:

	- Use `UNAVAILABLE` if the client can retry just the failing call.
	- Use `FAILED_PRECONDITION` if the client should not retry until
	the system state has been explicitly fixed.  E.g., if an "rmdir"
	     fails because the directory is non-empty, `FAILED_PRECONDITION`
	should be returned since the client should not retry unless
	the files are deleted from the directory.

	HTTP Mapping: 400 Bad Request or 500 Internal Server Error
	"""
	FAILED_PRECONDITION

	"""
	Internal error.

	An unexpected internal error was encountered. This means that some
	invariants expected by the underlying system have been broken.
	This error code is reserved for serious errors.

	HTTP Mapping: 500 Internal Server Error
	"""
	INTERNAL

	"""
	The requested entity was not found.

	This could apply to a resource that has never existed (e.g. bad resource id),
	or a resource that no longer exists (e.g. cache expired.)

	Note to server developers: if a request is denied for an entire class
	of users, such as gradual feature rollout or undocumented allowlist,
	`NOT_FOUND` may be used. If a request is denied for some users within
	a class of users, such as user-based access control, `PERMISSION_DENIED`
	must be used.

	HTTP Mapping: 404 Not Found
	"""
	NOT_FOUND

	"""
	The caller does not have permission to execute the specified
	operation.

	`PERMISSION_DENIED` must not be used for rejections
	caused by exhausting some resource or quota.
	`PERMISSION_DENIED` must not be used if the caller
	cannot be identified (use `UNAUTHENTICATED`
	instead for those errors).

	This error Type does not imply the
	request is valid or the requested entity exists or satisfies
	other pre-conditions.

	HTTP Mapping: 403 Forbidden
	"""
	PERMISSION_DENIED

	"""
	The request does not have valid authentication credentials.

	This is intended to be returned only for routes that require
	authentication.

	HTTP Mapping: 401 Unauthorized
	"""
	UNAUTHENTICATED

	"""
	Currently Unavailable.

	The service is currently unavailable.  This is most likely a
	transient condition, which can be corrected by retrying with
	a backoff.

	HTTP Mapping: 503 Unavailable
	"""
	UNAVAILABLE

	"""
	Unknown error.

	For example, this error may be returned when
	an error code received from another address space belongs to
	an error space that is not known in this address space.  Also
	errors raised by APIs that do not return enough error information
	may be converted to this error.

	If a client sees an unknown errorType, it will be interpreted as UNKNOWN.
	Unknown errors MUST NOT trigger any special behavior. These MAY be treated
	by an implementation as being equivalent to INTERNAL.

	When possible, a more specific error should be provided.

	HTTP Mapping: 520 Unknown Error
	"""
	UNKNOWN
}

type LoginError {
	username: String
}

input LoginInput {
	password: String!
	username: String!
}

union LoginResult = LoginError | LoginSuccess

type LoginSuccess {
	token: String
}

input MakePurchaseInput {
	basket: WhereUniqueBasketInput!
}

type MakePurchaseResult {
	basket: Basket
	purchase: Purchase
}

type Mutation {
	"""
	3.5 requires role User
	"""
	basketBook(input: BasketBookInput!): BasketBookResult

	"""
	3 requires role Admin
	"""
	createBook(input: CreateBookInput!): CreateBookResult

	"""
	3 requires role Admin
	"""
	delete(input: DeleteInput!): DeleteResult

	"""
	3
	"""
	login(input: LoginInput!): LoginResult

	"""
	4 requires role User
	"""
	makePurchase(input: MakePurchaseInput!): MakePurchaseResult

	"""
	3
	"""
	register(input: RegisterInput!): RegisterResult

	"""
	3.5 requires role User
	"""
	unbasketBook(input: UnbasketBookInput!): UnbasketBookResult

	"""
	4 requires role Admin
	"""
	updateStatus(input: UpdateStatusInput!): UpdateStatusResult
}

interface Node {
	id: ID!
}

enum Order {
	ASC
	DESC
}

type PageInfo {
	endCursor: String
	hasNextPage: Boolean!
	hasPreviousPage: Boolean!
	startCursor: String
}

type Price {
	formatted: String
	raw: Float
}

input PriceOrderBy {
	raw: Order
}

type Purchase implements Node {
	books(after: String, before: String, first: Int, last: Int): PurchaseBooksConnection
	createdAt: DateTime
	id: ID!
	price: Price
	status: PurchaseStatus
	user: User
}

type PurchaseBooksConnection {
	edges: [PurchaseBooksEdge]
	pageInfo: PageInfo!
}

type PurchaseBooksEdge {
	cursor: String
	node: Book
	price: Price
	quantity: Int
}

type PurchaseConnection {
	edges: [PurchaseEdge]
	pageInfo: PageInfo!
}

type PurchaseEdge {
	cursor: String
	node: Purchase
}

enum PurchaseStatus {
	AWAITING_PAYMENT
	COMPLETE
}

type Query {
	_service: _Service!

	"""
	3.5
	"""
	basket(id: ID): Basket

	"""
	3
	"""
	books(
		after: String
		before: String
		first: Int
		last: Int
		orderBy: [BookOrderBy]
	): BookConnection

	"""
	3
	"""
	hello: String

	"""
	3
	"""
	node(id: ID!): Node

	"""
	4
	"""
	purchases(after: String, before: String, first: Int, last: Int): PurchaseConnection

	"""
	3
	"""
	viewer: Viewer
}

type RegisterError {
	username: String
}

input RegisterInput {
	password: String!
	username: String!
}

union RegisterResult = RegisterError | RegisterSuccess

type RegisterSuccess {
	token: String
}

input Transformation {
	crop: String
	height: Int
	width: Int
}

input UnbasketBookInput {
	basket: WhereUniqueBasketInput
	book: WhereUniqueBookInput!
}

type UnbasketBookResult {
	basket: Basket
}

input UpdateStatusInput {
	iD: ID!
	status: PurchaseStatus!
}

type UpdateStatusResult {
	purchase: Purchase
}

"""
A custom scalar that represents files
"""
scalar Upload

type User implements Node & Viewer {
	id: ID!
	name: String
	purchases(after: String, before: String, first: Int, last: Int): PurchaseConnection
}

interface Viewer implements Node {
	id: ID!
}

input WhereUniqueBasketInput {
	id: ID!
}

input WhereUniqueBookInput {
	id: ID!
}

"""
"""
scalar _FieldSet

type _Service {
	sdl: String!
}
