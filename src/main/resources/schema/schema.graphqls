interface Node {
	id: ID!
}

type Price {
	formatted: String
	raw: Float
}

input Transformation {
	crop: String
	height: Int
	width: Int
}

"""
https://cloudinary.com/documentation/resizing_and_cropping#resize_and_crop_modes
"""
enum Crop {
	CROP
	FILL
	FILL_PAD
	FIT
	IMAGGA_CROP
	IMAGGA_SCALE
	LFILL
	LIMIT
	LPAD
	MFIT
	MPAD
	PAD
	SCALE
	THUMB
}

type BookConnection {
	edges: [BookEdge]
	pageInfo: PageInfo!
}
type BookEdge {
	cursor: String
	node: Book
}

type Cover {
	crop: String
	height: Int
	url: String
	width: Int
}
type Book implements Node {
	author: String
	covers(transformations: [Transformation]): [Cover]
	id: ID!
	popularity: Int
	price: Price
	recommended(after: String, before: String, first: Int, last: Int): BookConnection
	releasedAt: DateTime
	synopsis: String
	title: String
}

interface Viewer implements Node {
	id: ID!
}

type User implements Viewer & Node {
	id: ID!
	name: String
	purchases(after: String, before: String, first: Int, last: Int): PurchaseConnection
}

type Admin implements Viewer & Node {
	id: ID!
}

enum PurchaseStatus {
	AWAITING_PAYMENT
	COMPLETE
}

scalar DateTime
type PurchaseConnection {
	edges: [PurchaseEdge]
	pageInfo: PageInfo!
}

type PageInfo {
	endCursor: String
	hasNextPage: Boolean!
	hasPreviousPage: Boolean!
	startCursor: String
}

type PurchaseEdge {
	cursor: String
	node: Purchase
}
type Purchase implements Node {
	books(after: String, before: String, first: Int, last: Int): PurchaseBooksConnection
	createdAt: DateTime
	id: ID!
	price: Price
	status: PurchaseStatus
	user: User
}

type PurchaseBooksEdge {
	cursor: String
	node: Book
	price: Price
	quantity: Int
}

type PurchaseBooksConnection {
	edges: [PurchaseBooksEdge]
	pageInfo: PageInfo!
}

type BasketBooksEdge {
	cursor: String
	node: Book
	price: Price
	quantity: Int
}

type BasketBooksConnection {
	edges: [BasketBooksEdge]
	pageInfo: PageInfo!
}

type Basket {
	books(after: String, before: String, first: Int, last: Int): BasketBooksConnection
	id: ID!
	price: Price
}

enum Order {
	ASC
	DESC
}

input PriceOrderBy {
	raw: Order
}

input BookOrderBy {
	popularity: Order
	price: PriceOrderBy
	releasedAt: Order
}

type Query {
	"""
	3.5
	"""
	basket(id: ID): Basket
	"""
	3
	"""
	books(
		after: String
		before: String
		first: Int
		last: Int
		orderBy: [BookOrderBy]
	): BookConnection
	"""
	3
	"""
	hello: String
	"""
	3
	"""
	node(id: ID!): Node
	"""
	4
	"""
	purchases(after: String, before: String, first: Int, last: Int): PurchaseConnection
	"""
	3
	"""
	viewer: Viewer
}

input UpdateStatusInput {
	iD: ID!
	status: PurchaseStatus!
}

type MakePurchaseResult {
	basket: Basket
	purchase: Purchase
}

scalar Upload

input CreatePriceInput {
	raw: Float!
}

input CreateCoverInput {
	file: Upload
	url: String
}
input CreateBookInput {
	author: String!
	cover: CreateCoverInput!
	price: CreatePriceInput!
	releasedAt: DateTime!
	title: String!
}

type BasketBookResult {
	basket: Basket
}

type UnbasketBookResult {
	basket: Basket
}

type UpdateStatusResult {
	purchase: Purchase
}

input WhereUniqueBasketInput {
	id: ID!
}

input WhereUniqueBookInput {
	id: ID!
}

input BasketBookInput {
	basket: WhereUniqueBasketInput
	book: WhereUniqueBookInput!
}

input UnbasketBookInput {
	basket: WhereUniqueBasketInput
	book: WhereUniqueBookInput!
}

input DeleteInput {
	id: ID!
}

type CreateBookResult {
	book: Book
}

type DeleteResult {
	node: Node
}

input MakePurchaseInput {
	basket: WhereUniqueBasketInput!
}

type Mutation {
	"""
	3.5 requires role User
	"""
	basketBook(input: BasketBookInput!): BasketBookResult
	"""
	3 requires role Admin
	"""
	createBook(input: CreateBookInput!): CreateBookResult

	"""
	3 requires role Admin
	"""
	delete(input: DeleteInput!): DeleteResult
	"""
	3
	"""
	login(input: LoginInput!): LoginResult

	"""
	4 requires role User
	"""
	makePurchase(input: MakePurchaseInput!): MakePurchaseResult
	"""
	3
	"""
	register(input: RegisterInput!): RegisterResult
	"""
	3.5 requires role User
	"""
	unbasketBook(input: UnbasketBookInput!): UnbasketBookResult
	"""
	4 requires role Admin
	"""
	updateStatus(input: UpdateStatusInput!): UpdateStatusResult
}

type LoginResult {
	token: String
}

input LoginInput {
	password: String!
	username: String!
}
type RegisterResult {
	token: String
}

input RegisterInput {
	password: String!
	username: String!
}

schema {
	query: Query
	mutation: Mutation
}
